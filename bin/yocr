#!/usr/bin/python3


###################################################################
#
# FOSS Compliance Utils / yocr
#
# SPDX-FileCopyrightText: 2020 Henrik Sandklef
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
###################################################################

import os.path
#import os
#import getpass
#import datetime
import sys
import glob
#from re import search
#import re 
import json
import argparse
#import subprocess
#import time
#from datetime import date
from argparse import RawTextHelpFormatter

PROGRAM_NAME="yocr (yoga's compliance reporter)"
PROGRAM_DESCRIPTION="yocr compiles license compliance information from a Yocto build (as produced by yoda and yoga) and writes a report in various formats"
PROGRAM_VERSION="0.1"
PROGRAM_URL="https://github.com/vinland-technology/compliance-utils"
PROGRAM_COPYRIGHT="(c) 2020 Henrik Sandklef<hesa@sandklef.com>"
PROGRAM_AUTHOR="Henrik Sandklef"
PROGRAM_LICENSE="GPL-3.0-or-later"

PROGRAM_SEE_ALSO="yoda (Yocto Dependency analyzer)\n  yoga (Yoda's Generic Aggregator)\n  flict (FOSS License Compatibility Tool)"
OUTPUT_LICENSE="\"Public domain\""
OUTPUT_FORMATS="\n    JSON\n    html"
OUTPUT_FORMAT="JSON"
OUTPUT_DIR="./yocr-output"
INPUT_DIR="./yoga-output"

def error(msg):
    sys.stderr.write(msg + "\n")

def verbose(msg):
    if VERBOSE:
        sys.stderr.write(msg)
        sys.stderr.write("\n")
        sys.stderr.flush()

#
def read_flict_file(package, directory):
    flict_exit_code=None
    flict_file=directory + "/" + package + "-compliance.txt"
    try:
        with open(flict_file) as f:
            flict_exit_code=f.readline().replace("\n","").strip()
    except Exception as e:
        #print("exception: " + str(e))
        pass
    return flict_exit_code

def read_flict_report(package, directory):
    flict_report=directory + "/" + package + "-compliance-report.json"
    try:
        with open(flict_report) as fp:
            return json.load(fp)
    except Exception as e:
        #print("exception: " + str(e))
        pass
    return None
    
def read_package_info(package, directory):
    
    flict_json = directory + "/" + package + "-pile-flict.json"
    print("reading: " + flict_json)
    try:
        map={}
        with open(flict_json) as fp:
             json_data=json.load(fp)
             fp.close()
             return json_data
    except Exception as e:
        #print("exception: " + str(e))
        pass
    return None

def copyright_and_license_file_present(package, version, directory):
    cop_lic_file=directory + "/" + package + "-" + str(version) + "-lic-cop.zip"
    try:
        with open(cop_lic_file) as fp:
            fp.close()
            return cop_lic_file
    except:
        pass
    return False
    

def source_code_file_present(package, version, directory):
    cop_lic_file=directory + "/" + package + "-" + str(version) + "-src.zip"
    try:
        with open(cop_lic_file) as fp:
            fp.close()
            return cop_lic_file
    except:
        pass
    return None

def read_from_json(json_data, key):
    if key != None and json_data != None and key in json_data:
        return json_data[key]
    return None

def read_from_json_bool(json_data, key):
    if key != None and json_data != None and key in json_data and json_data[key]:
        return "OK" #json_data[key]
    return "missing"



def license_expression(license_list):
    outer_lic_expr=""
    for lic in license_list:
        lic_expr=""
        for inner_lic in lic:
            if (lic_expr==""):
                lic_expr = inner_lic['spdx']
                #print("lic_ " + lic_expr)
            else:
                lic_expr = lic_expr + " & " + inner_lic['spdx']
        if (outer_lic_expr==""):
            outer_lic_expr = lic_expr
        else:
            outer_lic_expr = outer_lic_expr + " | " + lic_expr
        
    return outer_lic_expr

def outbound_license(package):
    report = package['flictReport']
    #    print("---------------- report? " + str(report))
    policy_types=[ "allowed", "avoid", "denied" ]

    for policy_type in policy_types:
        if report != None and policy_type in report['outbound'] and len(report['outbound'][policy_type]) > 0:
            expr = license_expression(report['outbound'][policy_type])
            #print("expr: " + expr)
            return expr
    return "unknown"

def read_package_dir(package, directory):
    map={}
    map['name']=package
    verbose("    * reading " + directory + "(" + package +")")

    # package information
    package_json=read_package_info(package, directory)
    #print("p: " + str(package_json))
    component=read_from_json(package_json, 'component')
    #print("c: " + str(component))
    ## declared license
    map['declaredLicense']=read_from_json(component, 'license')
    
    version=read_from_json(component, 'version')
    map['version']=version
    #print("v: " + str(map['version']))
    #print("m: " + str(map))
    #print("l: " + str(map['declaredLicense']))
    #print("")
    #print("")
    #print("")

    # flict exit code
    map['flictExitCode']=read_flict_file(package, directory)
    # flict compliance report
    map['flictReport']=read_flict_report(package, directory)

    # copyright and license file present
    map['copyrightLicenseFile']=copyright_and_license_file_present(package, version, directory)
    # source code file present
    map['sourceCodeFile']=source_code_file_present(package, version, directory)
    
    return map

def read_yoga_dir(directory):
    dir = directory + "/*"
    packages={}
    verbose("reading " + dir)
    for file in glob.glob(dir):
        if os.path.isdir(file):
            verbose(" * " + file)
            package=file.replace(directory, "").replace("/","")
            map = read_package_dir(package, file)
            packages[package]=map

    return packages

def flict_exit_code_to_str(exit_code):
    #    print("exit_code: " + str(exit_code ))

    if exit_code == None:
        return "unknown"
    
    if exit_code == "0":
        return "OK"
    elif exit_code == "1":
        return "OK (with avoid)"
    elif exit_code == "2":
        return "OK (with denied)"
    else:
        return "unknown"

def write_html_package(package):

    #print("write: " + str(package))
    res =       "    <div class=\"complianceTableRow\">\n"
    res = res + "      <div class=\"complianceTableCell\">" + read_from_json(package, 'name') + "</div>\n"
    res = res + "      <div class=\"complianceTableCell\">" + str(read_from_json(package, 'version')) + "</div>\n"
    res = res + "      <div class=\"complianceTableCell\">" + str(read_from_json(package, 'declaredLicense')) + "</div>\n"
    res = res + "      <div class=\"complianceTableCell\">" + flict_exit_code_to_str(read_from_json(package, 'flictExitCode')) + "</div>\n"
    res = res + "      <div class=\"complianceTableCell\">" + str(outbound_license(package)) + "</div>\n"
    res = res + "      <div class=\"complianceTableCell\">" + str(read_from_json_bool(package, 'copyrightLicenseFile')) + "</div>\n"
    res = res + "      <div class=\"complianceTableCell\">" + str(read_from_json_bool(package, 'sourceCodeFile')) + " </div>\n"
    res = res + "    </div>\n"
    return res
              
def write_html(packages):
    res = ""
    res = res +  "<html lang=\"en-US\">\n"
    res = res +  "  <head> \n"
    res = res +  "    <link rel=\"stylesheet\" href=\"yocto-compliance.css\">\n"
    res = res +  "  </head>\n"
    res = res +  "  <body>\n"
    res = res +  "  <h1>Yocto build compliance</h1>\n"
    res = res +  "  <h2>Summary</h2>\n"
    res = res +  "  <h3>${#PACKAGES[@]} packages</h3>\n"
    res = res +  "  <ul>\n"
    res = res +  "    <li>${MISSING_FILE} with missing report (unsupported license, only contains script, text, configuration)</li>\n"    
    res = res +  "  </ul>\n"
    res = res +  "<h2>Packages</h2>\n"
    res = res +  "  <div class=\"complianceTable\">\n"
    res = res +  "    <div class=\"complianceTableRow\">\n"
    res = res +  "      <div class=\"complianceTableHead\"><strong>Package</strong></div>\n"
    res = res +  "      <div class=\"complianceTableHead\"><strong>Version</strong></div>\n"
    res = res +  "      <div class=\"complianceTableHead\"><strong>License</strong></div>\n"
    res = res +  "      <div class=\"complianceTableHead\"><strong>Compatible</strong></div>\n"
    res = res +  "      <div class=\"complianceTableHead\"><strong>Outbound</strong></div>\n"
    res = res +  "      <div class=\"complianceTableHead\"><strong>Copyright & License</strong></div>\n"
    res = res +  "      <div class=\"complianceTableHead\"><strong>Source code</strong></div>\n"
    res = res +  "    </div>\n"
    
    for pkg in packages:
        #print(str(packages[pkg]))
        res = res + write_html_package(packages[pkg])

    res = res +  "  </div>\n"
    res = res +  "</table>\n"
    res = res +  "</body></html>\n"

    return res
              
def write_json(packages):
    return json.dumps(packages)
    

def fmt_funs():
    fmt_funs={}
    fmt_funs['json']=write_json
    fmt_funs['html']=write_html
    return fmt_funs

def parse():

    description = "NAME\n  " + PROGRAM_NAME + "\n\n"
    description = description + "DESCRIPTION\n  " + PROGRAM_DESCRIPTION + "\n\n"
    
    epilog = ""
    epilog = epilog + "OUTPUT\n  Supported output formats:  " + OUTPUT_FORMATS + "\n\n"
    epilog = epilog + "  The output of this program is licensed under " + OUTPUT_LICENSE + "\n\n"
    epilog = epilog + "AUTHOR\n  " + PROGRAM_AUTHOR + "\n\n"
    epilog = epilog + "REPORTING BUGS\n  File a ticket at " + PROGRAM_URL + "\n\n"
    epilog = epilog + "COPYRIGHT\n  Copyright " + PROGRAM_COPYRIGHT + ".\n  License " + PROGRAM_LICENSE + "\n\n"
    epilog = epilog + "SEE ALSO\n  " + PROGRAM_SEE_ALSO + "\n\n"
    
    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=RawTextHelpFormatter
        )
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='output verbose information to stderr', default=False)
    parser.add_argument('-f', '--format', type=str,
                        help='output result in specified format(s) separated by colon, default is ' + OUTPUT_FORMAT, default=OUTPUT_FORMAT)
    parser.add_argument('-yd', '--yoga-dir', type=str, dest='yoga_dir', 
                        help='directory where yoga\'s output is located, default is ' + INPUT_DIR, default=INPUT_DIR)
    parser.add_argument('-d', '--output-dir', type=str, dest='outdir', 
                        help='directory for reports, default is ' + OUTPUT_DIR, default=OUTPUT_DIR)

    args = parser.parse_args()
    global VERBOSE
    VERBOSE=args.verbose

    return args

def main():
    args = parse()
    #TODO: find css:  print( os.path.dirname(os.path.realpath(__file__))+"/../var/yocto-compliance.css" )
    verbose("verbose: " + str(args.verbose))
    verbose("mode:    " + str(args.format))

    packages = read_yoga_dir(args.yoga_dir)

    fmt_functions=fmt_funs()
    
    for fmt in args.format.split(":"):
        open(args.outdir + "/compliance-result." + fmt.lower(), "w").write(fmt_functions[fmt.lower()](packages))
        

if __name__ == '__main__':
    main()


