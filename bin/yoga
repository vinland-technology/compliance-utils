#!/bin/bash

###################################################################
#
# FOSS Compliance Utils / yoga
#
# SPDX-FileCopyrightText: 2020 Henrik Sandklef
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
###################################################################

PROGRAM_NAME="Yoga (Yoda's Generic Aggregator)"
PROGRAM_VERSION="0.1"
PROGRAM_URL="https://github.com/vinland-technology/compliance-utils"
PROGRAM_COPYRIGHT="(c) 2020 Henrik Sandklef<hesa@sandklef.com>"
LICENSE="GPL-3.0-or-later"
OUTPUT_LICENSE="public domain"


SPDX_TRANSLATION_FILE=./spdx-translation.json
DEFAULT_YOGA_CONFIG=yoga.conf
COMPATIBILITY_CHECK=true

# yoga -d 20201204180707  -mtd ../sources -m britz -dd tmp/work/all-mbient-linux tmp/work/armv8a-mbient-linux tmp/work/britz-mbient-linux  -i apricot-image-ui-britz

OUT_DIR=compliance-results/

error()
{
    echo "$*" 1>&2
}

prefer_first_var()
{
    if [ "$1" != "" ]
    then
        echo "$1"
    else
        echo "$2"
    fi
}

read_config()
{
    CFG="$1"

    if [ ! -f "${CFG}" ]
    then
        error "Can't find configuration file: \"$CFG\""
        exit 1
    fi

    # Store current variables
    SAVE_DATE="$DATE"
    SAVE_MACHINE="$MACHINE"
    SAVE_IMAGE="$IMAGE"
    SAVE_BUILD_DIRS="${BUILD_DIRS}"
    SAVE_META_TOP_DIR="${META_TOP_DIR}"

    # Read variables from conf file
    error "Reading configurations from \"${DEFAULT_YOGA_CONFIG}\""
    source "${CFG}"

    # If variable was set before reding conf, reuse prior value
    DATE=$(prefer_first_var        "$SAVE_DATE"           "$DATE")
    MACHINE=$(prefer_first_var     "$SAVE_MACHINE"       "$MACHINE")
    IMAGE=$(prefer_first_var       "$SAVE_IMAGE"         "$IMAGE")
    BUILD_DIRS=$(prefer_first_var  "$SAVE_BUILD_DIRS"    "${BUILD_DIRS}")
    META_TOP_DIR=$(prefer_first_var"$SAVE_META_TOP_DIR"  "${META_TOP_DIR}")
}


while [ "$1" != "" ]
do
    case "$1" in
        "--build-dirs" | "-bd")
            BUILD_DIRS="$BUILD_DIRS $2"
            shift
	    while [ "$2" != "" ]
	    do
		if [[ "$2" == -* ]]
		then
		    break
		else
		    BUILD_DIRS="$BUILD_DIRS $2"
		    shift
		fi
	    done
            ;;
        "--image" | "-i")
            IMAGE="$2"
            shift
            ;;
        "--meta-top-dir" | "-mtd")
            META_TOP_DIR="$2"
            shift
            ;;
        "--license-translation-file" | "-ltf")
            SPDX_TRANSLATION_FILE="$2"
            shift
            ;;
        "--dist-dir" | "-dd")
            DIST_DIR="$2"
            shift
            ;;
        "--machine" | "-m")
            MACHINE="$2"
            shift
            ;;
        "--date" | "-d")
            DATE="$2"
            shift
            ;;
        "--verbose" | "-v")
            VERBOSE=" -v "
            ;;
        "--out-dir" | "-od")
            OUTDIR="$2"
            ;;
        "--list-imagepackages" | "-la")
            LIST_IMAGEPACKAGES="true"
            ;;
        "--config" | "-c")
            YOGA_CONFIG="$2"
            read_config "${YOGA_CONFIG}"
            ;;
        "--no-compatibility-checks" | "-ncc")
            COMPATIBILITY_CHECK=false
            ;;
        *)
	    echo assume pkg $1
            # assume package
            if [ "$PACKAGE" = "" ]
            then
                WANTED_PACKAGE="$1"
            fi
    esac
    shift
done

if [ "${YOGA_CONFIG}" != "" ]
then
    read_config "${YOGA_CONFIG}"
elif [ -f "${DEFAULT_YOGA_CONFIG}" ]
then
    read_config "${DEFAULT_YOGA_CONFIG}"
fi

LOG_FILE=${OUT_DIR}/$(basename $0).log
ERR_FILE=${OUT_DIR}/$(basename $0).err
mkdir -p $OUT_DIR



IMAGEPACKAGES_JSON=${OUT_DIR}/imagepackage-${IMAGE}-${DATE}.json

exit_code_to_text()
{
    if [ $1 -eq 0 ]
    then
        echo OK
    else
        echo FAIL
    fi
}

really_create_ipkg_json()
{
    yoda ${YBTF_ARGS} list > ${IMAGEPACKAGES_JSON}
    if [ $? -eq 0 ]
    then
        echo "OK"
    else
        echo "Fail"
	#rm  ${IMAGEPACKAGES_JSON}
        exit 1
    fi
}

#
# Create imagepackage JSON
#
create_imagepackage_json()
{
    inform0n "Creating imagepackages file ${IMAGEPACKAGES_JSON}: "
    if [ ! -f ${IMAGEPACKAGES_JSON} ]
    then
	really_create_ipkg_json
    elif [ ! -z ${IMAGEPACKAGES_JSON} ]	 
    then
	echo "File exists but is empty. Recreating it."
	inform0n "Creating imagepackages file ${IMAGEPACKAGES_JSON}: "
	really_create_ipkg_json
    else
        echo "OK (using existing)"
    fi
}


#
# Create JSON
#
create_json()
{
    inform2n "Creating component JSON: "
    local COMPONENT_JSON=${PERMANENT_OUT_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}-component.json
    if [ ! -f ${COMPONENT_JSON} ]
    then
	#echo "yoda ${YBTF_ARGS} ${PACKAGE_ARGS} exportpackage"
        yoda ${YBTF_ARGS} ${PACKAGE_ARGS} exportpackage  > ${COMPONENT_JSON}
        RET=$?
        echo "RETURNED: $RET"
        which yoda
        if [ $RET -ne 0 ]
        then
            inform0 "yoda ${YBTF_ARGS} ${PACKAGE_ARGS} exportpackage      failed"
            return
        fi
        echo "OK"
    else
        echo "OK (using old)"
    fi
}


#
# Split package json in to separate ones 
#
split_package_json()
{
    inform2n "Splitting component file"
    PKG_JSON=${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION}/${PACKAGE}-component.json
    yoda2flict.py -of tree -od ${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION} ${PKG_JSON}
    if [ $? -ne 0 ]
    then
        echo "yoda2flict.py -of tree -od ${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION} ${PKG_JSON} failed"
        return
    else
        echo "OK"
    fi
    FLICT_JSON_FILES=$(find ${PERMANENT_OUT_DIR}/${PACKAGE}/${VERSION} -name "*-tree-flict.json")

#    SUB_PKG_BASE=${PERMANENT_OUT_DIR}/$PACKAGE/${PACKAGE}-component
#    LAST_INDEX=$(jq ".packageFiles | keys | .[]"  $PKG_JSON | tail -1)
#    JSON_FILES=""
#    for i in $(seq 0 $LAST_INDEX)
#    do
#        VALID=$(jq ".packageFiles[$i].component.valid" $PKG_JSON )
#        NAME=$(jq ".packageFiles[$i].file" $PKG_JSON | sed 's,\",,g')
#        inform3n "$NAME: "
#        if [ "$VALID" != "false" ]
#        then
#            SUB_PKG_JSON=$SUB_PKG_BASE-$NAME.json
#            #echo "$i  $NAME $SUB_PKG_JSON  ($VALID)"
#            jq ".packageFiles[$i]"   $PKG_JSON > $SUB_PKG_JSON
#            JSON_FILES="$JSON_FILES $SUB_PKG_JSON"
#            echo OK
#        else
#            echo "invalid, ingored"
#        fi
#    done
}

#
# Verify JSON files
#
verify_json()
{
    inform2 "Verifying JSON files for $PACKAGE"
    for jf in $JSON_FILES
    do
        #    echo " * $jf"
        inform3n "$(basename $jf): "
        #printf " * %-${FILE_FMT_LEN}s " "$(basename $jf):"
        jq '.' $jf >/dev/null 2>&1
        RET=$?
        if [ $RET -ne 0 ]
        then
            echo "Fail (jq '.' $jf failed)"
            return
        else
            echo "OK"            
        fi
    done
}   

#
# Create flict component files
#
create_flict_json()
{
    inform2n "Creating flict component JSON: "
    local COMPONENT_JSON=${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION}/${PACKAGE}-component.json
    if [ ! -f ${COMPONENT_JSON} ]
    then
        echo "Could not find $COMPONENT_JSON (for $PACKAGE)"
        return
    fi

    # This is how yoda2flict.py names the put
    FLICT_COMPONENT_JSON=${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION}/${PACKAGE}-pile-flict.json
    yoda2flict.py -od ${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION}/ ${COMPONENT_JSON}
    if [ $? -ne 0 ]
    then
        echo "yoda2flict.py -od ${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION}/  ${COMPONENT_JSON} failed"
        return
    else
        echo "OK"
        FLICT_JSON_FILES="$FLICT_COMPONENT_JSON $FLICT_JSON_FILES"
    fi
    #echo "$FLICT_JSON_FILES"; exit 12
}



#
# Create package graphs
#
create_graphs_helper()
{
    local DOT_FILE="$1"
    local FORMAT="$2"
    
    dot -T${FORMAT} -O $DOT_FILE
    if [ $? -ne 0 ]
    then
        echo "dot -T${FORMAT} -O $DOT_FILE failed"
        return
    fi
}


create_graphs()
{
    inform2 "Creating dot and graph files ($JSON_FILES)"
    RES=OK
    for jf in $FLICT_JSON_FILES $JSON_FILES
    do
        jf_short=$(basename $jf)
        inform3n "$jf_short: "
        DOT_FILE=${GRAPH_OUT_DIR}/$jf_short.dot
        #printf " * %-${FILE_FMT_LEN}s " "$(basename $DOT_FILE):"
        flict-to-dot.py $jf > $DOT_FILE
        if [ $? -ne 0 ]
        then
            echo "Fail (flict-to-dot.py $jf > $DOT_FILE)"
            RES=Fail
        else
            echo -n "OK ("
            for fmt in pdf png svg
            do
                echo -n " $fmt"
                create_graphs_helper  $DOT_FILE $fmt
            done
            echo ")"
        fi
    done
}


fix_json()
{
    JF=$1
    EXPR="$2"
#    echo "cat $jf | sed $SED_EXPR" 
    echo "cat $jf | $SED_EXPR" | bash 
}

#
# Fixing license expressions
#
fix_license_expressions()
{
    inform2 "Fixing license expressions in JSON files"
    if [ "${SPDX_TRANSLATION_FILE}" = "" ] 
    then
        inform3n "Ignoring since no SPDX translation file provided"	
	JSON_FIXED_FILES="${FLICT_COMPONENT_JSON}"
        echo "OK"
	return 
    fi
    JSON_FIXED_FILES=""
    RES=OK
    for jf in ${FLICT_COMPONENT_JSON}
    do
        jf_short=$(basename $jf)
        inform3n "$jf_short"
        SPDX_TRANSLATION_FILE=./spdx-translation.json
        FIXED_JSON=${PERMANENT_OUT_DIR}/${PACKAGE}/${VERSION}/$(basename $(echo $jf | sed 's,\.json,-fixed\.json,g'))
        #FIXED_JSON=${PERMANENT_OUT_DIR}/${PACKAGE}/$(basename $(echo $jf | sed 's,\.json,-fixed\.json,g'))
        spdx-translations.py -stf ${SPDX_TRANSLATION_FILE} -p $jf > $FIXED_JSON
        #echo "spdx-translations.py ${SPDX_TRANSLATION_FILE} $jf > $FIXED_JSON"
        #fix_json $FIXED_JSON "$SED_EXPR"  > $FIXED_JSON
        RET=$?
        if [ $RET -ne 0 ]
        then
            echo "Failed (spdx-translations.py ${SPDX_TRANSLATION_FILE} $jf > $FIXED_JSON)"
            RES=Fail
            # TODO: store failed files
        else
            echo "OK"
            JSON_FIXED_FILES="$JSON_FIXED_FILES $FIXED_JSON"
        fi
    done
}

#
# Dirty hacks done dirt cheap
#
dirty_hacks_done_dirt_cheap()
{
    inform2 "---===  DIRTY HACK (temporary)  ===---"
    inform2 "Fixing license expressions in a dirty way"
    for jf in $JSON_FIXED_FILES
    do
        inform3n "$(basename $jf): "
        #printf " * %-${FILE_FMT_LEN}s %s" "$(basename $jf):"
        mv ${jf} ${jf}.tmp
        cat ${jf}.tmp |
            sed \
                -e 's,BSD-2,BSD-3,g' \
                -e 's,BSD-4,BSD-3,g' \
                -e 's,MIT-style,MIT,g' \
                > ${jf}
        RET=$?
        if [ $RET -ne 0 ]
        then
            echo "Failed"
        else
            echo "OK"
        fi
        rm -f ${jf}.tmp
    done
}

#
# Verify fixed JSON files
#
verified_fixed_json()
{
    inform2 "Verifying fixed JSON files for $PACKAGE"
    for jf in $JSON_FIXED_FILES
    do
        inform3n "$(basename $jf): "
        #printf " * %-${FILE_FMT_LEN}s " "$(basename $jf):"
        jq '.' $jf >/dev/null 2>&1
        RET=$?
        if [ $RET -ne 0 ]
        then
            echo "Failed "
        else
            echo "OK"
        fi
    done
}

#
# Check license compliance with flict
#
check_license_compliance()
{
    inform2 "Checking license compliance (flict)"
    for jf in  $JSON_FIXED_FILES
    do
        inform3n "$(basename $jf) "
        JSON_REPORT=${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION}/$PACKAGE-compliance-report.json
        TXT_REPORT=${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION}/$PACKAGE-compliance.txt
        #printf " * %-${FILE_FMT_LEN}s " "$(basename $jf):"
        set -o pipefail
        ~/.local/bin/flict --json -c $jf | tail -1 | jq '.' > ${JSON_REPORT}
#        echo ~/.local/bin/flict --json -c $jf #| tail -1 | jq '.' > ${JSON_REPORT}
        RET=$?
        echo "$RET" > $TXT_REPORT
        flict_exit_code_to_string $RET
    done
}


package_name_no_trailing_version()
{
    local PACKAGE=$1
    echo $PACKAGE | sed 's,[\]*[-0-9\.]*$,,g'
}

libx_src_dir()
{
    local BUILD_DIR="$1"
    local PACKAGE=$2
    local VERSION=$3
    local VERSION_SHORT_TRIMMED=$4

    find ${BUILD_DIR}/${PACKAGE}/${VERSION}/* -type d -prune | grep -i "${PACKAGE}-${VERSION_SHORT_TRIMMED}"
}

gstreamer_src_dir()
{
    local BUILD_DIR="$1"
    local PACKAGE=$2
    local VERSION=$3
    local VERSION_SHORT_TRIMMED=$4

    echo ${BUILD_DIR}/${PACKAGE}/${VERSION}/$(echo $PACKAGE | sed 's,gstreamer[0-9\.]*,gst,g')-${VERSION_SHORT_TRIMMED}
}

#
# Collect source code
#
collect_source_code()
{
    RES=OK
    local FAILED_DIRS
    inform2 "Collecting source code"
    VERSION_SHORT_TRIMMED=$(echo ${VERSION_SHORT} | sed 's,[0-9]*_,,g')

    LIBX_FIXES_DIR=$(libx_src_dir ${BUILD_DIR} ${PACKAGE} ${VERSION} ${VERSION_SHORT_TRIMMED})
    
    NO_TRAILING_DIR=${BUILD_DIR}/${PACKAGE}/${VERSION}/$(package_name_no_trailing_version $PACKAGE)-${VERSION_SHORT_TRIMMED}

    GST_DIR=$(gstreamer_src_dir  ${BUILD_DIR} ${PACKAGE} ${VERSION} ${VERSION_SHORT_TRIMMED})
    #    libx_src_dir ${BUILD_DIR} ${PACKAGE} ${VERSION} ${VERSION_SHORT_TRIMMED}

    local TRY_DIRS=""
    for BUILD_DIR in $BUILD_DIRS
    do
	TRY_DIRS="$TRY_DIRS ${BUILD_DIR}/${PACKAGE}/${VERSION}/archiver-work  ${BUILD_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}-${VERSION_SHORT}  ${BUILD_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}-${VERSION_SHORT_TRIMMED}   ${BUILD_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}-src   ${BUILD_DIR}/${PACKAGE}/${VERSION}/git ${BUILD_DIR}/${PACKAGE}/packages-split/${PACAKAGE}-src/  ${BUILD_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}-${VERSION_SHORT_TRIMMED}  ${BUILD_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}/source ${LIBX_FIXES_DIR} ${NO_TRAILING_DIR} ${GST_DIR}"
    done
    
    
    RES=Fail
    inform3n "Finding src directory: "
    for dir in $TRY_DIRS
    do
        #echo "TRYING DIR: $dir"
        pushd ${dir}  >/dev/null 2>&1
        RET=$?
        NR_FILES=$(ls -1 | wc -l)
        if [ $RET -eq 0 ] && [ $NR_FILES -gt 0 ]
        then
            : #echo "found a place: $dir"
            RES=OK
            break
        else
            popd  >/dev/null 2>&1
        fi
    done
    echo "$RES"
    sync
    if [ "$RES" != "OK" ]
    then
        return
    fi

    ZIP_FILE=${PERMANENT_OUT_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}-${VERSION_SHORT}-src.zip
    inform3n "Creating zip file: "
    zip -r  ${ZIP_FILE} .  >/dev/null 2>&1
    if [ $? -ne 0 ]
    then
        echo "Fail (zip -r ${ZIP_FILE} .)"
    else
        echo "OK"
    fi
    popd  >/dev/null 2>&1
}


#
# Collect license information
#
collect_license_copyright_information()
{
    inform2 "Collecting copyright and license information" 

    for BUILD_DIR in $BUILD_DIRS
    do
	#inform3 "BUILD_DIR: $BUILD_DIR" 
        #inform3n "${BUILD_DIR}" 
	#for sub_dir in "${PACKAGE}/${VERSION}/packages-split/${PACKAGE}-lic/usr/share/licenses/${PACKAGE}/" "license-destdir/${PACKAGE}"
	for sub_dir in "${PACKAGE}/${VERSION}/packages-split/${PACKAGE}-lic/usr/share/licenses/${PACKAGE}/" "${PACKAGE}/${VERSION}/license-destdir/${PACKAGE}"
	do
	    #inform3 "    COP_LIC_DIR: $COP_LIC_DIR"
	    COP_LIC_DIR=${BUILD_DIR}/$sub_dir
            inform3 "  ${COP_LIC_DIR}" 
	    if [ -d ${COP_LIC_DIR} ]
	    then
		inform3n "Trying $COP_LIC_DIR: " 
		pushd ${COP_LIC_DIR} >/dev/null 2>&1
		if [ $? -ne 0 ]
		then
		    echo "Fail (pushd ${COP_LIC_DIR})"
		    popd
		    return
		fi
		echo "OK"
		sync
		
		ZIP_FILE=${PERMANENT_OUT_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}-${VERSION_SHORT}-lic-cop.zip
		inform3n "Creating zip file: "
		zip -r ${ZIP_FILE} .  > /dev/null 2>&1
		if [ $? -ne 0 ]
		then
		    echo "Fail (zip -r ${ZIP_FILE})"
		else
		    echo "OK"
		fi
		return
	    fi
	done
    done
    popd  >/dev/null 2>&1
}


check_if_closed()
{
    for BUILD_DIR in $BUILD_DIRS
    do
	SPEC_FILE=${BUILD_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}.spec
	if [ -f ${SPEC_FILE} ]
	then
	    LICENSES=$(grep "License:" ${SPEC_FILE} | sed 's,License:,,g' | tr '[A-Z]' '[a-z]')
	    declare -A LICENSE_MAP
	    for lic in $LICENSES
	    do
		LICENSE_MAP[$lic]="exists"
	    done
	    LIC_CNT=${#LICENSE_MAP[@]}
	    
	    case $LIC_CNT in
		"0")
		    echo "No license found in ${PACKAGE}/${VERSION}/${PACKAGE}.spec"
		    ;;
		"1")
		    CLOSED=$(echo ${!LICENSE_MAP[@]} | grep -i closed | wc -l)
		    if [ $CLOSED -eq 0 ]
		    then
			echo "foss"
		    else
			echo "closed"
		    fi
		    ;;
		*)
		    CLOSED=$(echo ${!LICENSE_MAP[@]} | grep -i closed | wc -l)
		    #            echo "too many licenses??? (${!LICENSE_MAP[@]})"
		    if [ $CLOSED -eq 0 ]
		    then
			echo "foss"
		    else
			echo "mix"
			#                echo "mixed licenses: ${!LICENSE_MAP[@]}" 1>&2
		    fi
		    ;;
	    esac
	    return
	fi
    done
}

per_package()
{
    local PACKAGE=$1
    local SUB_PACKAGES=$2
    local VERSION=$3
    local VERSION_SHORT=$4
    
    GRAPH_OUT_DIR=${PERMANENT_OUT_DIR}/$PACKAGE/${VERSION}/graphs
    mkdir -p $GRAPH_OUT_DIR

    inform2n "Checking if package already done: "
    DONE_PLACEHOLDER=${PERMANENT_OUT_DIR}/${PACKAGE}/${VERSION}/${PACKAGE}-${VERSION_SHORT}-done.placeholder
    if [ -f ${DONE_PLACEHOLDER} ]
    then
        echo " done ($(basename $DONE_PLACEHOLDER) already present)"
        return
    fi
    echo "not done, continuing"
    sync
    
#    inform2n "Checking if package already has been marked closed source: "
#    CLOSED_PLACEHOLDER=${PERMANENT_OUT_DIR}/${PACKAGE}/${PACKAGE}-${VERSION_SHORT}-closed-source.placeholder
#    if [ -f ${CLOSED_PLACEHOLDER} ]
#    then
#        echo "${PACKAGE} marked as closed source, ignoring"
#        return
#    fi
#    echo "FOSS or mix, continuing"
#    sync

    inform2n "Getting license type: "    
    LICENSE_INFO=$(check_if_closed)
    
    #echo "LICENSE_INFO: $LICENSE_INFO"
    case $LICENSE_INFO in
        "closed")
            echo "closed license"
            touch ${CLOSED_PLACEHOLDER}
            return
            ;;
        "mix")
            echo "mixed licenses, continuing"
            ;;
        "foss")
            echo "FOSS licenses only, continuing"
            ;;
        "")
            echo "unknown"
            ;;
    esac
    sync
    
    create_json "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 
    FLICT_JSON_FILES=""
    split_package_json "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 
    verify_json "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 

    create_flict_json "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 
    
    create_graphs "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 

    fix_license_expressions "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 
    dirty_hacks_done_dirt_cheap "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 
    verified_fixed_json "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 
    check_license_compliance "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 
    collect_source_code "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 
    collect_license_copyright_information "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT" 

    touch ${DONE_PLACEHOLDER}
}

flict_exit_code_to_string()
{
    local EXIT_CODE="$1"
    if [ "$EXIT_CODE" = "" ]
    then
        echo "unknown"
        return
    fi
    
    case "$EXIT_CODE" in
        "0")
            echo "OK"
            ;;
        "1")
            echo OK "(avoided licenses only)"
            ;;
        "2")
            echo FAIL "(denied licenses only)"
            ;;
        *)
            #            echo "FAIL ($EXIT_CODE)"
            echo "Check failed (unsupported license?)"
            ;;
    esac
}


license_from_type()
{
    if [ ! -f $2 ]
    then
        echo "unknown"
        return
    fi
    
    JSON_DATA=$(cat $2)

    local type=$1
    export TY=$type
#    echo "$type"
 #   echo "$2"
    # get number of list items for this type
    type_size=$(echo $JSON_DATA | jq ".outbound.$TY | length")
    #echo " * type: $TY  elements: $type_size"
    local COMP_LICENSE_EXPRESSION=""
    if [ "$type_size" != "" ] && [ $type_size -gt 0 ]
    then
        RANGE_END=$(( $type_size - 1 ))
        RANGE="$(seq 0 $RANGE_END)"
        # loop over the list item (arrays)
        for elem_index in $RANGE
        do
            #echo " * type: $TY  elements: $type_size  elem_index: $elem_index"
            export IDX=$elem_index
            LICENSE_EXPRESSION=""
            for lic in $(echo $JSON_DATA | jq -r ".outbound.$TY[$IDX][].spdx")
            do
                #echo "add \"$lic\""
                lic_url="<a href=\"https://spdx.org/licenses/$lic.html\">$lic</a>"
                if [ "$LICENSE_EXPRESSION" = "" ]
                then
                    LICENSE_EXPRESSION="$lic_url"
                else
                    LICENSE_EXPRESSION="${LICENSE_EXPRESSION} & ${lic_url}"
                fi
            done
    #        echo "$type: \"$LICENSE_EXPRESSION\""
            if [ "$COMP_LICENSE_EXPRESSION" = "" ]
            then
                COMP_LICENSE_EXPRESSION="$LICENSE_EXPRESSION"
            else
                COMP_LICENSE_EXPRESSION="${COMP_LICENSE_EXPRESSION} | ${LICENSE_EXPRESSION}"
            fi
        done
    fi
    echo "$COMP_LICENSE_EXPRESSION"
}




YBTF_ARGS=" $VERBOSE -d $DATE  -m $MACHINE  -i $IMAGE -bd ${BUILD_DIRS}  -mtd ${META_TOP_DIR} "


FILE_FMT_LEN=70
FILE_FMT_INDENT1_LEN=$(( $FILE_FMT_LEN - 3 ))
FILE_FMT_INDENT2_LEN=$(( $FILE_FMT_LEN - 6 ))
FILE_FMT_INDENT3_LEN=$(( $FILE_FMT_LEN - 9 ))

verbose()
{
    echo "$*" 1>&2
}

inform0()
{
    printf "%-${FILE_FMT_LEN}s\n" "$*"  
}

inform0n()
{
    printf "%-${FILE_FMT_LEN}s" "$*"  
    sync
}

inform1()
{
    printf " * %-${FILE_FMT_INDENT1_LEN}s\n" "$*" 
}

inform1n()
{
    printf " * %-${FILE_FMT_INDENT1_LEN}s" "$*"  
    sync
}

inform2()
{
    printf "    * %-${FILE_FMT_INDENT2_LEN}s\n" "$*" 
}

inform2n()
{
    printf "    * %-${FILE_FMT_INDENT2_LEN}s" "$*"
    sync
}

inform3()
{
    printf "       * %-${FILE_FMT_INDENT3_LEN}s\n" "$*" 
}

inform3n()
{
    printf "       * %-${FILE_FMT_INDENT3_LEN}s" "$*"  
    sync
}


check_env_var()
{
    NAME=$1
    VALUE=$2

    
}

output_config()
{
    echo "#####################################################"
    echo "#"
    echo "# Automatically created onfiguration file for Yoga"
    echo "#"
    echo "# License:  MIT"
    echo "#"
    echo "# Created:  $(date)"
    echo "# OS:       $(uname -a)"
    echo "# Host:     $(hostname)"
    echo "# User:     $(whoami)"
    echo "#"
    echo "#"
    echo "# Yoga"
    echo "#   project page: https://github.com/vinland-technology/compliance-utils/"
    echo "#   bug report:   https://github.com/vinland-technology/compliance-utils/issues"
    echo "#"
    echo "#####################################################"
    echo ""
    echo "# DATE - build date"
    echo "DATE=\"$DATE\""
    echo ""
    echo "# MACHINE - machine this image was built for"
    echo "MACHINE=\"$MACHINE\""
    echo ""
    echo "# IMAGE - name of the image"
    echo "IMAGE=\"$IMAGE\""
    echo ""
    echo "# BUILD_DIRS - list of directories where the build results are stored"
    echo "BUILD_DIRS=\"${BUILD_DIRS}\""
    echo ""
    echo "# META_TOP_DIR - top directory for the meta files (e.g recipes/bb)"
    echo "META_TOP_DIR=\"${META_TOP_DIR}\""
    echo
    echo
}

check_config()
{
    
    check_env_var $DATE
    check_env_var $MACHINE
    check_env_var $IMAGE
    check_env_var ${BUILD_DIRS}
    check_env_var ${META_TOP_DIR}

    # If no config file, create one from the settings we have
    if [ "${YOGA_CONFIG}" = "" ]
    then
        if [ ! -f "${DEFAULT_YOGA_CONFIG}" ]
        then
            output_config > "${DEFAULT_YOGA_CONFIG}"
        fi
    fi
    
    # SPDX translation file
    if [ "${SPDX_TRANSLATION_FILE}" != "" ] && [ ! -f ${SPDX_TRANSLATION_FILE} ]
    then
	error "Missing license translation file \"${SPDX_TRANSLATION_FILE}\""
	exit 1
    fi

    
}



#
# MAIN
#

check_config

exit


PERMANENT_OUT_DIR=$(pwd)/${OUT_DIR}
LOG_FILE=${PERMANENT_OUT_DIR}/$(basename $0 | sed 's,\.sh,\.log,g').log

# This is needed for what ever we do
create_imagepackage_json 2>${ERR_FILE}

if [ "$LIST_IMAGEPACKAGES" = "true" ]
then
    echo "Listing imagepackage"
    # TODO: use jq's raw option
    jq '.imagepackages[].name' ${IMAGEPACKAGES_JSON} | sed 's,\",,g' | sort
    exit $?
fi


#create_imagepackage_json | tee ${LOG_FILE}
declare -A PACKAGES
declare -A VERSIONS
declare -A VERSIONS_SHORT
inform0n "Extracting information about packages (in imagepackage list): "
# TODO: use jq's raw option
for line in $(jq '.imagepackages[] | "\(.package):\(.subPackage):\(.valid):\(.name):\(.packageVersion):\(.packageVersionDir)"' ${IMAGEPACKAGES_JSON} | sed 's,\",,g' | sort)
do
    VALID=$(echo $line | cut -d : -f 3)
    if [ "$VALID" = "true" ]
    then
        PACKAGE=$(echo $line | cut -d : -f 1)
        SUB_PACKAGE=$(echo $line | cut -d : -f 2)
        if [ "${PACKAGES[$PACKAGE]}" = "" ]
        then
            VERSION_SHORT=$(echo $line | cut -d : -f 5)
            VERSION=$(echo $line | cut -d : -f 6)
            PACKAGES[$PACKAGE]="$SUB_PACKAGE"
            VERSIONS[$PACKAGE]="$VERSION"
            VERSIONS_SHORT[$PACKAGE]="$VERSION_SHORT"
        else
            PACKAGES[$PACKAGE]="${PACKAGES[$PACKAGE]}:$SUB_PACKAGE"
        fi
    else
        # TODO: manage/present the ones that we could not handle
        NAME=$(echo $line | cut -d : -f 4)
        #echo "ERROR: $NAME ($line)"
    fi    
done
inform0 "OK"

if [ "$WANTED_PACKAGE" = "" ]
then
    inform0 "Listing all packages"
else
    inform0 "Listing single package $WANTED_PACKAGE"
fi

for PACKAGE in "${!PACKAGES[@]}"
do
#    echo "PACKAGE: $PACKAGE (\"$WANTED_PACKAGE\")"
    if [ "$WANTED_PACKAGE" = "" ] || [ "$WANTED_PACKAGE" = "$PACKAGE" ] 
    then
        SUB_PACKAGES=${PACKAGES[$PACKAGE]}
        SP_COUNT=$(( $( echo ${PACKAGES[$PACKAGE]} | grep -o ":" | wc -l) + 1 ))
        inform1 "$PACKAGE / $SP_COUNT sub packages"
        PACKAGE_ARGS=" -p $PACKAGE -sp $SUB_PACKAGES "
        #    echo "$VERSION | $VERSION_SHORT"
        export VERSION=${VERSIONS[$PACKAGE]}
        VERSION_SHORT=${VERSIONS_SHORT[$PACKAGE]}
        per_package "$PACKAGE" "$SUB_PACKAGES" "$VERSION" "$VERSION_SHORT"
        exit
    fi
done 2>>${ERR_FILE} | tee -a ${LOG_FILE} 

echo done
#set -o pipefail
#all | tee $LOG_FILE 
#RET=$?
#exit $RET
